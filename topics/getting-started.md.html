<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Restia</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Restia</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Requirements">Requirements </a></li>
<li><a href="#Creating_a_project">Creating a project </a></li>
<li><a href="#Adding_a_Page">Adding a Page </a></li>
<li><a href="#Making_it_bot_friendly">Making it bot-friendly </a></li>
</ul>


<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/readme.md.html">readme</a></li>
  <li><a href="../topics/license.md.html">license</a></li>
  <li><strong>getting-started</strong></li>
  <li><a href="../topics/controllers.md.html">controllers</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/restia.attributes.html">restia.attributes</a></li>
  <li><a href="../modules/restia.commands.html">restia.commands</a></li>
  <li><a href="../modules/restia.bin.manpage.html">restia.bin.manpage</a></li>
  <li><a href="../modules/restia.config.html">restia.config</a></li>
  <li><a href="../modules/restia.handler.html">restia.handler</a></li>
  <li><a href="../modules/restia.logbuffer.html">restia.logbuffer</a></li>
  <li><a href="../modules/restia.markdown.html">restia.markdown</a></li>
  <li><a href="../modules/restia.negotiator.html">restia.negotiator</a></li>
  <li><a href="../modules/restia.request.html">restia.request</a></li>
  <li><a href="../modules/restia.secret.html">restia.secret</a></li>
  <li><a href="../modules/restia.template.html">restia.template</a></li>
  <li><a href="../modules/restia.utils.html">restia.utils</a></li>
</ul>
<h2>Scripts</h2>
<ul class="nowrap">
  <li><a href="../scripts/restia.html">restia</a></li>
</ul>

</div>

<div id="content">

    <h1>Getting Started with Restia</h1>

<p>TODO: Update to reflect changes in default skeleton project.</p>

<p><a name="Requirements"></a></p>

<h2>Requirements</h2>

<p>This tutorial will assume you have</p>

<ul>
<li>A working installation of any Linux distro</li>
<li>A working installation of <a href="http://openresty.org/en/" title="OpenResty is a dynamic web platform based on NGINX and LuaJIT.">Openresty</a></li>
<li>Openrestys version of nginx in the PATH as <code>openresty</code></li>
<li>A working installation of Luarocks</li>
<li>The <code>curl</code> commandline tool</li>
</ul>


<p><a name="Creating_a_project"></a></p>

<h2>Creating a project</h2>

<p>First of all, you will need to install Restia:</p>

<pre>
$ luarocks install restia <span class="comment">--dev --lua-version 5.1</span>
</pre>


<p>Some of restias dependancies may require additional libraries to be present on
your system.
How to install these libraryes will depend on what operating system you are
using;
for ubuntu-based systems you might want to use <code>apt install</code>.</p>

<p>After that, you can run <code>restia new</code> to create a new project:</p>

<pre>
$ restia new app
$ cd application
</pre>


<p>Now you can take a moment to inspect the directory structure.
This is also a good moment to create a git repository
and commit everything in the directory.
There&rsquo;s already a bunch of <code>.gitignore</code> files
so you don&rsquo;t commit anything unnecessary.</p>

<pre>
$ git init
$ git add <span class="comment">--all
</span>$ git commit -m <span class="string">'Initialize project ðŸŽ‰'</span>
</pre>


<p>At this point you can already run your application:</p>

<pre>
$ restia run
</pre>


<p>And open <code>http://localhost:8080/</code> in the browser
to be greeted with a plain but working website.</p>

<p><a name="Adding_a_Page"></a></p>

<h2>Adding a Page</h2>

<p>The scaffolding application generated by <code>restia new app</code> assumes a
Model-View-Controler structure. If necessary, this can be changed, of course.</p>

<p><strong>Let&rsquo;s add a new page at /hi, which will say hi to the user.</strong></p>

<h3>Add a Controller</h3>

<p>First, we will create the <code>controllers/hi.lua</code> file
with the following content:</p>

<pre>
<span class="keyword">local</span> views = <span class="global">require</span> <span class="string">"views"</span>

<span class="keyword">return</span> <span class="keyword">function</span>(req)
    <span class="keyword">return</span> ngx.say(views.hi { name = <span class="string">"Restia"</span> })
<span class="keyword">end</span>
</pre>


<p><details>
<summary>Restia looks for controllers in <code>/controllers</code></summary></p>

<p>The default location block found in <code>locations/root</code> sets nginx up so
for any requested route <code>foo/bar</code> it looks for a controller in
<code>controllers/foo/bar.lua</code> unless any other (more specific) location
block matches first.</p>

<p>Since <code>/</code> is the least specific location possible,
this will always be tried last and gets overridden by anything that matches
the route in question.
<hr>
</details></p>

<h3>Add a View</h3>

<p>With the controller set up to handle the application logic,
next we need a view to render some output to the user.</p>

<p><details>
<summary>Templates in Restia are all just functions that accept a table of
parameters and return some output as a string.</summary></p>

<p>To examplify this; one could even write a template as a plain Lua file.
for example, open a file <code>views/hi.lua</code> and add the following code:</p>

<pre>
<span class="keyword">return</span> <span class="keyword">function</span>(parameters) <span class="comment">-- This function is our "template"
</span>    <span class="keyword">return</span> <span class="string">"&lt;h1&gt;Hello from "</span> .. parameters.name .. <span class="string">"!&lt;/h1&gt;"</span>
<span class="keyword">end</span>
</pre>


<p>to achieve the same result as what&rsquo;s explained below.
However, writing templates this way is cumbersome,
which is why this would rarely be done in a real project.</p>

<p>Hint: If you tried this out, don&rsquo;t forget to delete <code>views/hi.lua</code> before
continuing the guide, otherwise it will override the templates you will create
next ;)
<hr>
</details></p>

<p>Let&rsquo;s start with some simple HTML.
First, create a new cosmo template by opening a file <code>views/hi.cosmo</code>
and adding the following:</p>

<pre>
&lt;h1&gt;Hello World!&lt;/h1&gt;
</pre>


<p>Restia will now find this file whenever we access <code>require(&quot;views&quot;).hi</code>
and return a function that returns the final output.</p>

<p>You can start restia and confirm the result if you want.</p>

<p>However, in most cases we'd want to add some dynamic content to our templates,
otherwise we'd just be serving static files over plain nginx.
Let&rsquo;s do that by changing the template to:</p>

<pre>
&lt;h1&gt;Greetings from $name!&lt;/h1&gt;
</pre>


<p>The <code>$name</code> in the template gets replaced with &ldquo;Restia&rdquo; because of the <code>{name =
"Restia"}</code> we pass through in the controller.</p>

<p>Now, you can start restia again and look at the result in the browser.
This time though, let&rsquo;s just keep restia running in the background.</p>

<pre>
$ restia run &amp;
</pre>


<h3>Making the template <em>Multistage</em></h3>

<p>For small snippets, writing HTML is quite acceptable.
But when you're working on a large application,
all those opening and closing tags can get very cumbersome to type.</p>

<p>For this reason, restia has an additional templating engine called MoonXML.
It&rsquo;s very flexible because &ldquo;templates&rdquo; are really just <em>code</em> that runs in a
special environments where missing functions are generated on the fly to print
HTML tags.
This also makes moonhtml templates considerably slower than a more simple
templating engine like cosmo, so Restia lets you combine the two into a
<em>multistage template</em>.</p>

<p>Let&rsquo;s first rename the hi template to <code>views/hi.cosmo.moonhtml</code> and
change the content to</p>

<pre>
h1 <span class="string">"Greetings from $name!"</span>
</pre>


<p>Restia will now load it as a moonhtml-cosmo multistage template; that is,
the first time you <em>access</em> the <code>views.hi</code> template in your code,
it will load the file as a <strong>moonhtml</strong> template and render it right then and
there.</p>

<p>However, the resulting string is not displayed yet; instead, it is loaded
as a cosmo template and saved into the <code>views</code> table. From now on, every
time you access <code>views.hi</code>, you will get the pre-rendered cosmo template.</p>

<p>What this means, is that you can insert dynamic content at both stages, which
can be a bit confusing at first.
To illustrate this,
let&rsquo;s add two timestamps to our template in <code>views/hi.cosmo.moonhtml</code>:</p>

<pre>
h1 <span class="string">"Greetings from $name!"</span>
p <span class="string">"Rendered: $time"</span>
p <span class="string">"Pre-rendered: "</span>..<span class="global">os</span>.date()
</pre>


<p>and modify the controller at <code>controllers/hi.lua</code>
to pass an additional parameter:</p>

<pre>
<span class="keyword">return</span> ngx.say(views.hi { name = <span class="string">"Restia"</span>, time = <span class="global">os</span>.date() })
</pre>


<p>Now open the page in the browser again.</p>

<p>The first time you open the page, the two paragraphs should (almost) the same
time.
However, if you wait a few seconds and reload the page,
the first timestamp should have changed,
but the second one should remain the same.</p>

<p>Summarizing this behavior as a rule of thumb:</p>

<p><strong>Cosmo parameters change on every render.</strong>
They can be identified by the <code>$</code> and the fact that they appear within strings.</p>

<p><strong>MoonHTML expressions get evaluated only once.</strong>
They appear as normal variables, function calls or other expressions in the
MoonHTML template.</p>

<p>You can make use of this by rendering certain content in the MoonXML stage if it
onle relies on information that doesn&rsquo;t change once the server is running, like
a navigation menu, generated URLs for resources, etc.</p>

<p>Also keep in mind that there are also plain, single-stage MoonHTML templates
that get rehdered every time.
They can be identified by the single <code>.moonhtml</code> file extension.</p>

<p>Most importantly though: The <strong>controller</strong> shouldn&rsquo;t care about the type of
<em>template</em> it&rsquo;s dealing with.
The controller just renders a parametrized <strong>view</strong>,
which, by convention is a function as described above.</p>

<p><a name="Making_it_bot_friendly"></a></p>

<h2>Making it bot-friendly</h2>

<p>We already have a nice HTML page, but what about computers? They don&rsquo;t like
looking at HTML pages nearly as much as human users do. Instead, let&rsquo;s ofer
them the same content in a more machine-readable format.</p>

<p>To achieve this, first replace the line that renders the view with:</p>

<pre>
req:offer {
    {<span class="string">"text/html"</span>, <span class="keyword">function</span>(req)
        <span class="keyword">return</span> views.greeter { name = <span class="string">"Restia"</span>, time = <span class="global">os</span>.date() }
    <span class="keyword">end</span>};
}
</pre>


<p>This matches the users <code>accept</code> header against a list of available content-types
and renders the best match. When two content-types are equally prefered by the
client, it will just take the first one, so it is always a good idea to put the
computationally cheaper content-types at the top.</p>

<p>Notice the missing <code>ngx.say</code>: <code>req:offer</code> takes care of that automatically.</p>

<p>Now we can add another content type to the list:</p>

<pre>
{<span class="string">"application/json"</span>, <span class="keyword">function</span>(req)
    <span class="keyword">return</span> json.encode { name = <span class="string">"Restia"</span>, time = <span class="global">os</span>.date() }
<span class="keyword">end</span>};
</pre>


<p>and, of course, actually define <code>json</code> as some module that can encode JSON data.
Luckily, OpenResty comes bundled with one, so you can just add <code>local json =
require 'cjson'</code> at the top of the file.</p>

<p>As you may have noticed, there&rsquo;s some duplication there: the table that gets
sent to the template looks identical to the one that gets encoded as JSON. This
isn&rsquo;t always the case, but rather often, it is. We can just extract that table
into a variable and put it on top of the content negotiation code.</p>

<p>The final controller should look something like this:</p>

<pre>
<span class="comment">-- Require some modules
</span><span class="keyword">return</span> <span class="keyword">function</span>(req)
    <span class="keyword">local</span> data = { name = <span class="string">"Restia"</span>, time = <span class="global">os</span>.date() }
    req:offer {
        {<span class="string">"application/json"</span>, <span class="keyword">function</span>(req)
            <span class="keyword">return</span> json.encode(data)
        <span class="keyword">end</span>};
        {<span class="string">"text/html"</span>, <span class="keyword">function</span>(req)
            <span class="keyword">return</span> views.greeter(data)
        <span class="keyword">end</span>};
    }
<span class="keyword">end</span>
</pre>


<p>You can confirm this by calling in your terminal</p>

<pre>
curl localhost:<span class="number">8080</span>/hi -H <span class="string">'accept: application/json'</span>
curl localhost:<span class="number">8080</span>/hi -H <span class="string">'accept: text/html'</span>
curl localhost:<span class="number">8080</span>/hi -H <span class="string">'accept: application/json;q=.3,text/html;q=.5'</span>
</pre>


<p>And in case the server has no acceptable content-type for the client, it will
return an error instead:</p>

<pre>
curl localhost:<span class="number">8080</span>/hi -H <span class="string">'accept: application/yaml'</span>
</pre>



</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2021-01-03 16:45:09 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
