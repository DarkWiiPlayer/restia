# Getting Started with Restia

## Requirements

This tutorial will assume you have

- A working installation of any Linux distro
- A working installation of [Openresty][openresty]
- Openrestys version of nginx in the PATH as `nginx`
- A working installation of Luarocks

## Creating a project

First of all, you will need to install Restia:

	$ luarocks install restia --dev --lua-version 5.1

After that, you can run `restia new` to create a new project,
passing it the directory where you want the project to be created:

	$ restia new application
	$ cd application

Now you can take a moment to inspect the directory structure.
This is also a good moment to create a git repository
and commit everything in the directory.
There's already a `.gitignore` file
so you don't commit anything unnecessary.

	$ git init
	$ git add --all
	$ git commit -m 'Initialize project ðŸŽ‰'

At this point you can already run your application:

	$ restia run
	
And open `http://localhost:8080/` in the browser
to be greeted with a plain but working website.

## Adding a Page

The scaffolding application generated by `restia new` assumes a
Model-View-Controler structure. If necessary, this can be changed, of course.

**Let's add a new page, `/greet`, which will greet the user.**

### Add a Controller

First, we will create the `controllers/greeter.lua` file
with the following content:

	local restia = require 'restia'
	local config = require "config"
	local views = require "views"

	restia.controller.xpcall(function()
		return ngx.say(views.greeter { name = "Restia" })
	end, require 'error')

<details>
<summary>Restia looks for controllers in <code>/controllers</code></summary>

The default location block found in <code>locations/root</code> sets nginx up so
for any requested route <code>foo/bar</code> it looks for a controller in
<code>controllers/foo/bar.lua</code> unless any other (more specific) location
block matches first.

Since <code>/</code> is the least specific location possible,
this will always be tried last and gets overridden by anything that matches
the route in question.
<hr>
</details>

The relevant code is really just

	return ngx.say(views.greeter { name = "Restia" })

It calls a view "greeter" with the parameter `name = "Restia"`.

We could write our code directly in the controller file,
but the `restia.controller.xpcall` wrapper provides better outputs in case of
errors directly in the browser and allows us to easily disable this in
production.

The `error` module is what actually handles the error case and
generates the outpus; it can be found and modified in `lib/error.lua`.

The `config` and `views` modules are also not part of the core restia library,
but are autogenerated modules in the `lib` subdirectory.

### Add a View

With the controller set up to handle the application logic,
next we need a view to render some output to the user.

<details>
<summary>Templates in Restia are all just functions that accept a table of
parameters and return some output as a string.</summary>

To examplify this; one could even write a template as a plain Lua file.
for example, open a file `views/greeter.lua` and add the following code:

	return function(parameters) -- This function is our "template"
		return "<h1>Hello from " .. parameters.name .. "!</h1>"
	end

to achieve the same result as what's explained below.
However, writing templates this way is cumbersome,
which is why this would rarely be done in a real project.

Hint: If you tried this out, don't forget to delete `views/greeter.lua` before
continuing the guide, otherwise it will override the templates you will create
next ;)
<hr>
</details>

Let's start with some simple HTML.
First, create a new cosmo template by opening a file `views/greeter.cosmo`
and adding the following:

	<h1>Hello World!</h1>

Restia will now find this file whenever we access `require("views").greeter`
and return a function that returns the final output.

You can start restia and confirm the result if you want.

However, in most cases we'd want to add some dynamic content to our templates,
otherwise we'd just be serving static files over plain nginx.
Let's do that by changing the template to:

	<h1>Greetings from $name!</h1>

The `$name` in the template gets replaced with "Restia" because of the `{name =
"Restia"}` we pass through in the controller.

Now, you can start restia again and look at the result in the browser.
This time though, let's just keep restia running in the background.

	$ restia run &

### Making the template *Multistage*

For small snippets, writing HTML is quite acceptable.
But when you're working on a large application,
all those opening and closing tags can get very cumbersome to type.

For this reason, restia has an additional templating engine called MoonXML.
It's very flexible because "templates" are really just *code* that runs in a
special environments where missing functions are generated on the fly to print
HTML tags.
This also makes moonhtml templates considerably slower than a more simple
templating engine like cosmo, so Restia lets you combine the two into a
*multistage template*.

Let's first rename the greeter template to `views/greeter.cosmo.moonhtml` and
change the content to

	h1 "Greetings from $name!"

Restia will now load it as a moonhtml-cosmo multistage template; that is,
the first time you *access* the `views.greeter` template in your code,
it will load the file as a **moonhtml** template and render it right then and
there.

However, the resulting string is not displayed yet; instead, it is loaded
as a cosmo template and saved into the `views` table. From now on, every
time you access `views.greeter`, you will get the pre-rendered cosmo template.

What this means, is that you can insert dynamic content at both stages, which
can be a bit confusing at first.
To illustrate this,
let's add two timestamps to our template in `views/greeter.cosmo.moonhtml`:

	h1 "Greetings from $name!"
	p "Rendered: $time"
	p "Pre-rendered: "..os.date()

and modify the controller at `controllers/greeter.lua`
to pass an additional parameter:

	return ngx.say(views.greeter { name = "Restia", time = os.date() })

Now open the page in the browser again.

The first time you open the page, the two paragraphs should (almost) the same
time.
However, if you wait a few seconds and reload the page,
the first timestamp should have changed,
but the second one should remain the same.

Summarizing this behavior as a rule of thumb:

**Cosmo parameters change on every render.**
They can be identified by the `$` and the fact that they appear within strings.

**MoonHTML expressions get evaluated only once.**
They appear as normal variables, function calls or other expressions in the
MoonHTML template.

You can make use of this by rendering certain content in the MoonXML stage if it
onle relies on information that doesn't change once the server is running, like
a navigation menu, generated URLs for resources, etc.

Also keep in mind that there are also plain, single-stage MoonHTML templates
that get rehdered every time.
They can be identified by the single `.moonhtml` file extension.

Most importantly though: The **controller** shouldn't care about the type of
*template* it's dealing with.
The controller just renders a parametrized **view**,
which, by convention is a function as described above.

[openresty]: http://openresty.org/en/ 'OpenResty is a dynamic web platform based on NGINX and LuaJIT.'
